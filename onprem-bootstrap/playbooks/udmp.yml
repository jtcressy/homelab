---
- name: udmp setup
  gather_facts: false
  hosts: unifiudm
  vars:
    udm_onboot_version: 1.0.5
    udm_onboot_download_uri: "https://github.com/boostchicken/udm-utilities/releases/download/{{ udm_onboot_version }}/udm-boot_{{ udm_onboot_version }}_all.deb"

    unifi_mount_path: "/mnt/data"
    unifi_os_mount_path: "/data"

    unifi_os_container: "unifi-os"
    unifi_os_cmd: podman exec -it "{{ unifi_os_container }}"

    unifi_onboot_directory: "{{ unifi_mount_path }}/on_boot.d/"

  tasks:
  - name: onboot - query package version
    register: onboot_version
    raw: "{{ unifi_os_cmd }} dpkg-query --showformat='${Version}' --show udm-boot"

  - name: onboot - installation
    when: onboot_version is not defined or ( onboot_version.stdout is defined and onboot_version.stdout != udm_onboot_version )
    block:
      - name: onboot - download package
        raw: curl -L "{{ udm_onboot_download_uri }}" -o "{{ unifi_mount_path }}/unifi-os/udm-boot-{{ udm_onboot_version }}.deb"
      - name: onboot - install package
        raw: "{{ unifi_os_cmd }} dpkg -i {{ unifi_os_mount_path }}/udm-boot-{{ udm_onboot_version }}.deb"

  - name: onboot - ensure onboot directory exists
    raw: mkdir -p "{{ unifi_onboot_directory }}"

  - name: onboot - deploy shell scripts
    block:
      - name: onboot - sshkeys
        raw: |-
          cat <<EOF > {{ unifi_onboot_directory }}/00-onboot-sshkeys.sh
          #!/bin/sh

          AUTHORIZED_KEYS=/root/.ssh/authorized_keys

          KEYS_RC=-1
          COUNT=0
          while [ ${KEYS_RC} -ne 0 ] && [ ${COUNT} -lt 60 ]
          do
              KEYS_DATA=$(podman exec unifi-os mongo --port 27117 --eval 'db.setting.find({key: {$eq: "mgmt"}}, {x_ssh_keys: 1, _id: 0});' --quiet ace)
              KEYS_RC=$?
              COUNT=$(( COUNT+1 ))
              [ ${KEYS_RC} -ne 0 ] && [ ${COUNT} -lt 60 ] && sleep 10
          done

          if [ ${KEYS_RC} -ne 0 ]
          then
              echo "Failed to load keys from config"
          else
              echo "${KEYS_DATA}" \
                  | sed 's/\"date\" : ISODate\(.*\),//' \
                  | jq -r '.x_ssh_keys | map([.type, .key, .comment] | join(" ")) | join("\n")' \
                  | while IFS= read -r KEY
              do
                  if ! grep -Fxq "${KEY}" "${AUTHORIZED_KEYS}"
                  then
                      echo "${KEY}" >> "${AUTHORIZED_KEYS}"
                  fi
              done
          fi
          EOF
      - name: onboot - podman update
        raw: |-
          cat <<EOF > {{ unifi_onboot_directory }}/03-onboot-podman-update.sh
          #!/bin/sh

          mkdir -p /mnt/data/.cache

          PODMAN_VERSION=3.3.0
          RUNC_VERSION=1.0.2
          CONMON_VERSION=2.0.29
          PODMAN_DL=/mnt/data/.cache/podman-$PODMAN_VERSION
          RUNC_DL=/mnt/data/.cache/runc-$RUNC_VERSION
          CONMON_DL=/mnt/data/.cache/conmon-$CONMON_VERSION
          SECCOMP=/usr/share/containers/seccomp.json

          while [ ! -f $CONMON_DL ]; do
            curl -fsSLo $CONMON_DL https://github.com/boostchicken/udm-utilities/blob/master/podman-update/bin/conmon-$CONMON_VERSION?raw=true
            sleep 1
          done
          chmod +x $CONMON_DL
          if [ ! -f /usr/libexec/podman/conmon.old ]; then
            mv /usr/libexec/podman/conmon /usr/libexec/podman/conmon.old
          fi
          ln -s $CONMON_DL /usr/libexec/podman/conmon

          if [ ! -f $PODMAN_DL ]; then
            curl -fsSLo $PODMAN_DL https://github.com/boostchicken/udm-utilities/blob/master/podman-update/bin/podman-$PODMAN_VERSION?raw=true
          fi
          chmod +x $PODMAN_DL
          if [ ! -f /usr/bin/podman.old ]; then
            mv /usr/bin/podman /usr/bin/podman.old
          fi
          ln -s $PODMAN_DL /usr/bin/podman

          if [ ! -f $RUNC_DL ]; then
            curl -fsSLo $RUNC_DL https://github.com/boostchicken/udm-utilities/blob/master/podman-update/bin/runc-$RUNC_VERSION?raw=true
          fi
          chmod +x $RUNC_DL
          if [ ! -f /usr/bin/runc.old ]; then
            mv /usr/bin/runc /usr/bin/runc.old
          fi
          ln -s $RUNC_DL /usr/bin/runc

          if [ ! -f $SECCOMP ]; then
            mkdir -p /usr/share/containers/
            curl -fsSLo $SECCOMP https://github.com/boostchicken/udm-utilities/blob/master/podman-update/bin/seccomp.json?raw=true
          fi
          sed -i 's/driver = ""/driver = "overlay"/' /etc/containers/storage.conf
          sed -i 's/ostree_repo = ""/#ostree_repo = ""/' /etc/containers/storage.conf
          # Comment out if you don't want to enable docker-compose or remote docker admin
          /usr/bin/podman system service --time=0 tcp:127.0.0.1:2375 &

          EOF
      - name: onboot - container
        raw: |-
          cat <<EOF > {{ unifi_onboot_directory }}/05-onboot-container.sh
          #!/bin/sh
          # This script runs before any custom containers start to adjust container common defaults

          # Set a limit for container logs. 104857600 Bytes = 100 Megabytes
          sed -i 's/max_log_size = -1/max_log_size = 104857600/g' /etc/containers/libpod.conf;

          if ! ip link show cni0; then
              ip link add cni0 type bridge || echo ""
          fi
          EOF
      - name: onboot - podman cni
        raw: |-
          cat <<EOF > {{ unifi_mount_path }}/podman/cni/20-dns.conflist
          {
            "cniVersion": "0.4.0",
            "name": "dns",
            "plugins": [
              {
                "type": "macvlan",
                "mode": "bridge",
                "master": "br5",
                "ipam": {
                  "type": "static",
                  "addresses": [
                    {
                      "address": "192.168.5.3/24",
                      "gateway": "192.168.5.1"
                    }
                  ],
                  "routes": [
                    {"dst": "0.0.0.0/0"}
                  ]
                }
              }
            ]
          }
          EOF
          cat <<EOF > {{ unifi_onboot_directory }}/05-onboot-podman-cni.sh
          #!/bin/sh
          # Change default pod cni to dns
          sed -i 's/cni_default_network = "podman"/cni_default_network = "dns"/g' /etc/containers/libpod.conf;

          ## Set the version of cni plugin to use. It will revert to latest if an invalid version is given, and the installer will use the last installed version if that fails.
          # Examples of valid version code would be "latest", "v0.9.1" and "v0.9.0".
          CNI_PLUGIN_VER=latest
          # location of the CNI Plugin cached tar files
          CNI_CACHE="/mnt/data/.cache/cni-plugins"
          # location of the conf files to go in the net.d folder of the cni-plugin directory
          CNI_NETD="/mnt/data/podman/cni"
          # The checksum to use. For CNI Plugin sha1, sha256 and sha512 are available.
          CNI_CHECKSUM="sha256"
          # Maximum number of loops to attempt to download the plugin if required - setting a 0 or negative value will reinstalled the currently installed version (if in cache)
          MAX_TRIES=3

          mkdir -p "${CNI_CACHE}" "${CNI_NETD}"
          # The script will attempt to use the nominated version first, and falls back to latest version if that fails
          if [ "$#" -eq 0 ]; then
            set ${CNI_PLUGIN_VER}
          fi
          # Insert conf files for podman networks into the net.d folder
          populate_netd()
          {
            for file in "${CNI_NETD}"/*.conflist
            do
              if [ -f "$file" ]; then
                  ln -fs "$file" "/etc/cni/net.d/$(basename "$file")"
              fi
            done
          }
          # This function checks a valid checksum has been selected. It requires the checksum is given as the first argument
          checksum_check()
          {
            if [ "$#" -eq 0 ]; then
              echo "no arguement given"
              return 2
            fi
            case $1 in
              "sha1" | "sha256" | "sha512")
                return 0;
                ;;
              *)
                echo "Incorrect checksum selection"
                return 1;
                ;;
            esac
          }
          # Test a file against it's checksum - 1 is the checksum type, 2 is the file to test and 3 is the checksum file
          checksum_test()
          {
            if [ ! -f ${2} ] || [ ! -f ${3} ]; then
              echo "file does not exist"
              return 2
            fi
            if ! checksum_check ${1}; then
              echo "An incorrect checksum has been used"
              return 3
            fi
            value1=$(${1}sum ${2} | awk '{print $1}')
            value2=$(cat ${3} | awk '{print $1}')
            if [ "${value1}" = "${value2}" ]; then
              return 0
            else
              return 1
            fi
          }

          # Install function - it requires the first argument to be the version to install
          install()
          {
            if [ "$#" -eq 0 ]; then
              set "installed"
            fi
            if [ -f "${CNI_CACHE}/cni-plugins-linux-arm64-$1.tgz" ]; then
              echo "Pouring ${CNI_CACHE}/cni-plugins-linux-arm64-$1.tgz"
              rm -rf /opt/cni/bin
              mkdir -p /opt/cni/bin
              tar -xzC /opt/cni/bin -f "${CNI_CACHE}/cni-plugins-linux-arm64-$1.tgz"
              # Create a link to installed version as fallback option
              if [ "$1" != "installed" ]; then
                ln -sf "${CNI_CACHE}/${CNI_TAR}" "${CNI_CACHE}/cni-plugins-linux-arm64-installed.tgz"
                ln -sf "${CNI_CACHE}/${CNI_TAR}.${CNI_CHECKSUM}" "${CNI_CACHE}/cni-plugins-linux-arm64-installed.tgz.${CNI_CHECKSUM}"
              fi
              return 0
            fi
            echo "No CNI Plugin available to install"
            return 1
          }
          # Download function - the first argument is the version to download. It will default to latest if a invalid option is given.
          download()
          {
            # To stop infinite recursion
            if [ ${MAX_TRIES} -lt 1 ]; then
              # install the last installed version if latest and specified version have both failed.
              install
              return 1
            fi
            # This defaults to latest, in case the specified download doesn't work.
            if [ "$#" -eq 0 ]; then
              set latest
            fi
            # Find the corect parameters
            set "$(basename "$(curl -fsSLo /dev/null -w "%{url_effective}" https://github.com/containernetworking/plugins/releases/$1)")" "$@"
            CNI_TAR="cni-plugins-linux-arm64-$1.tgz"
            URL="https://github.com/containernetworking/plugins/releases/download/$1/${CNI_TAR}"
            # Cache a checksum for the file
            if [ ! -f "${CNI_CACHE}/${CNI_TAR}.${CNI_CHECKSUM}" ]; then
              echo "Downloading ${URL}.${CNI_CHECKSUM}"
              curl -fsSLo "/tmp/${CNI_TAR}.${CNI_CHECKSUM}" "${URL}.${CNI_CHECKSUM}"
              mv "/tmp/${CNI_TAR}.${CNI_CHECKSUM}" "${CNI_CACHE}/${CNI_TAR}.${CNI_CHECKSUM}"
            fi
            # Cache the tar file
            if [ ! -f "${CNI_CACHE}/${CNI_TAR}" ]; then
              echo "Downloading ${URL}"
              curl -fsSLo "/tmp/${CNI_TAR}" "${URL}"
              mv "/tmp/${CNI_TAR}" "${CNI_CACHE}/${CNI_TAR}"
            fi
            # Symbolic link to latest
            if [ "$1" != "$2" ]; then
              ln -sf "${CNI_CACHE}/${CNI_TAR}" "${CNI_CACHE}/cni-plugins-linux-arm64-$2.tgz"
              ln -sf "${CNI_CACHE}/${CNI_TAR}.${CNI_CHECKSUM}" "${CNI_CACHE}/cni-plugins-linux-arm64-$2.tgz.${CNI_CHECKSUM}"
            fi
            # Test integrity of the files
            if ! checksum_test ${CNI_CHECKSUM} ${CNI_CACHE}/${CNI_TAR} ${CNI_CACHE}/${CNI_TAR}.${CNI_CHECKSUM}; then
              echo "Corrupt tar file, deleting tar and checksum"
              rm -f "${CNI_CACHE}/${CNI_TAR}" "${CNI_CACHE}/${CNI_TAR}.${CNI_CHECKSUM}"
              MAX_TRIES=${(MAX_TRIES - 1)}
              # try again on fallback of latest until retries are exhausted
              download
            else
              install $1 $2
              return 0
            fi
          }

          download
          populate_netd
          EOF
      - name: onboot - dns
        raw: |-
          cat <<EOF > {{ unifi_onboot_directory }}/05-onboot-dns.sh
          #!/bin/sh

          ## configuration variables:
          VLAN=5
          IPV4_IP="192.168.5.3"
          # This is the IP address of the container. You may want to set it to match
          # your own network structure such as 192.168.5.3 or similar.
          IPV4_GW="192.168.5.1/24"
          # As above, this should match the gateway of the VLAN for the container
          # network as above which is usually the .1/24 range of the IPV4_IP

          # if you want IPv6 support, generate a ULA, select an IP for the dns server
          # and an appropriate gateway address on the same /64 network. Make sure that
          # the 20-dns.conflist is updated appropriately. It will need the IP and GW
          # added along with a ::/0 route. Also make sure that additional --dns options
          # are passed to podman with your IPv6 DNS IPs when deploying the container for
          # the first time. You will also need to configure your VLAN to have a static
          # IPv6 block.

          # IPv6 Also works with Prefix Delegation from your provider. The gateway is the
          # IP of br(VLAN) and you can pick any ip address within that subnet that dhcpv6
          # isn't serving
          IPV6_IP=""
          IPV6_GW=""

          # set this to the interface(s) on which you want DNS TCP/UDP port 53 traffic
          # re-routed through the DNS container. separate interfaces with spaces.
          # e.g. "br0" or "br0 br1" etc.
          FORCED_INTFC=""

          # container name; e.g. nextdns, pihole, adguardhome, etc.
          CONTAINER=coredns

          if ! test -f /opt/cni/bin/macvlan; then
              echo "Error: CNI plugins not found. You can install it with the following command:" >&2
              echo "       curl -fsSLo /mnt/data/on_boot.d/05-install-cni-plugins.sh https://raw.githubusercontent.com/boostchicken/udm-utilities/master/cni-plugins/05-install-cni-plugins.sh && /bin/sh /mnt/data/on_boot.d/05-install-cni-plugins.sh" >&2
              exit 1
          fi

          # set VLAN bridge promiscuous
          ip link set br${VLAN} promisc on

          # create macvlan bridge and add IPv4 IP
          ip link add br${VLAN}.mac link br${VLAN} type macvlan mode bridge
          ip addr add ${IPV4_GW} dev br${VLAN}.mac noprefixroute

          # (optional) add IPv6 IP to VLAN bridge macvlan bridge
          if [ -n "${IPV6_GW}" ]; then
            ip -6 addr add ${IPV6_GW} dev br${VLAN}.mac noprefixroute
          fi

          # set macvlan bridge promiscuous and bring it up
          ip link set br${VLAN}.mac promisc on
          ip link set br${VLAN}.mac up

          # add IPv4 route to DNS container
          ip route add ${IPV4_IP}/32 dev br${VLAN}.mac

          # (optional) add IPv6 route to DNS container
          if [ -n "${IPV6_IP}" ]; then
            ip -6 route add ${IPV6_IP}/128 dev br${VLAN}.mac
          fi

          # Make DNSMasq listen to the container network for split horizon or conditional forwarding
          if ! grep -qxF interface=br$VLAN.mac /run/dnsmasq.conf.d/custom.conf; then
              echo interface=br$VLAN.mac >> /run/dnsmasq.conf.d/custom.conf
              kill -9 `cat /run/dnsmasq.pid`
          fi

          if podman container exists ${CONTAINER}; then
            podman start ${CONTAINER}
          else
            logger -s -t podman-dns -p ERROR Container $CONTAINER not found, make sure you set the proper name, you can ignore this error if it is your first time setting it up
          fi

          # (optional) IPv4 force DNS (TCP/UDP 53) through DNS container
          for intfc in ${FORCED_INTFC}; do
            if [ -d "/sys/class/net/${intfc}" ]; then
              for proto in udp tcp; do
                prerouting_rule="PREROUTING -i ${intfc} -p ${proto} ! -s ${IPV4_IP} ! -d ${IPV4_IP} --dport 53 -j DNAT --to ${IPV4_IP}"
                iptables -t nat -C ${prerouting_rule} || iptables -t nat -A ${prerouting_rule}

                # (optional) IPv6 force DNS (TCP/UDP 53) through DNS container
                if [ -n "${IPV6_IP}" ]; then
                  prerouting_rule="PREROUTING -i ${intfc} -p ${proto} ! -s ${IPV6_IP} ! -d ${IPV6_IP} --dport 53 -j DNAT --to ${IPV6_IP}"
                  ip6tables -t nat -C ${prerouting_rule} || ip6tables -t nat -A ${prerouting_rule}
                fi
              done
            fi
          done
          EOF
      - name: onboot - github ssh keys
        raw: |-
          cat <<EOF > {{ unifi_onboot_directory }}/05-onboot-github-ssh.sh
          #!/bin/sh
          GITHUB_USERNAME=jtcressy
          KEYS_B64=$( curl -H "Accept: application/vnd.github.v3+json" https://api.github.com/users/${GITHUB_USERNAME}/keys | jq '.[].key | @base64')
          KEYS_FILE="/root/.ssh/authorized_keys"

          for key_b64 in $KEYS_B64
          do
            key=$(echo $key_b64 | jq -r '@base64d')
            if ! grep -Fxq "$key" "$KEYS_FILE"; then
              echo "$key" >> "$KEYS_FILE"
            fi
          done

          EOF
      - name: onboot - coredns
        raw: |-
          cat <<EOF > {{ unifi_onboot_directory }}/10-onboot-coredns.sh

          EOF
      - name: onboot - tailscale
        raw: |-
          cat <<EOF > {{ unifi_onboot_directory }}/11-onboot-tailscale.sh
          #!/bin/sh
          CONTAINER=tailscaled
          IMAGE=ghcr.io/tailscale/tailscale:v1.18.2
          # Starts a Tailscale container that is deleted after it is stopped.
          # All configs stored in /mnt/data/tailscale
          if podman container exists ${CONTAINER}; then
            podman start ${CONTAINER}
          else
            mkdir -p /mnt/data/tailscale
            podman run --rm --device=/dev/net/tun --net=host --cap-add=NET_ADMIN --cap-add=SYS_ADMIN --cap-add=CAP_SYS_RAWIO -v /mnt/data/tailscale:/var/lib/tailscale --name=${CONTAINER} -d --entrypoint /bin/sh ${IMAGE} -c "tailscaled"
          fi
          EOF
      # - name: onboot - cloudflared
      # - name: onboot - tftpd

  - name: onboot - ensure executable flag for all scripts
    raw: chmod +x {{ unifi_onboot_directory }}/*.sh
